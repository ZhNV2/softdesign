## Usage

./gradlew cliJar
java -jar build/libs/cli-cli-all-1.0-SNAPSHOT.jar

## Structure

После считывания строка передается парсеру, который делает следующее.
Сначала делим строку по пайпам, внутри каждой команды делим весь текст на куски outside, spaces, inside_single_quotes, inside_double_quotes.
После этого в каждом куске пробуем сделать подстановку. Далее в каждом куске проверяем, не является ли эта команда равенством, иначе просто разбиваем все на команду + аргументы.
Результат работы парсера как раз и есть список команд в формате (название, аргументы).

Далее для каждой команды есть имплементатор интерфейса Command, который умеет выполнять команду, если ему передать аргументы, окружение и результат работы предыдущей команды (перед pipe).
Соответственно каждая следующая команда берет вход предыдущей и свои аргументы.

Environment - обертка для map для хранения пар (переменная, значения).
Его нужно передавать в парсер для выполнения подстановок и нужно передавать командам, так как некоторые (например, =) умеют его менять.

CommandResult - результат исполнения команды в формате (output, нужно ли заканчивать)
CommandCall - то, что возвращает парсер как описание одной команды в формате (name, args).

## Библиотеки парсинга

Посмотрев несколько библиотек для парсинга, более или менее все разбиваются на две категории: одни предлагают явно задавать опции в коде (обычно есть какой-нибудь класс Option, у него есть билдер, позволяющий задать параметры).
Вторый предлагают задать специальный класс с проанатированными полями и парсер во время работы заполянет эти поля специальными значениями.
Еще нашел одну интересную библиотеку, в которой предлагается гененировать парсер из xml (http://jcommando.sourceforge.net).
Идея кажется хорошей, но эта библиотека слишком малофункциональна (ей даже нельзя решить данную задачу).

Итого я реализовал разбор с помощью двух подходов. Были выбраны commons apache и JCommander.

С помощью апачи получается довольно простой код, все опции определяются рядом и сразу используются. Из минусов можно выделить то, что нельзя задать валидаторы для опций,
поэтому приходится проверять руками, нельзя задать разумный формат для аргументов (то есть паттерн и файл лежат просто в списке аргументов), также такое задание опций обязует
помнить и названия и типы опций как до определения параметров парсера, так и после (кастовать их тоже надо руками).

В случае JCommander-а все на порядок лучше. Формат всех опций вынесен в отдельный класс и потому отделен от самого кода, поэтому все параметры можно сразу посмотреть там, а не искать в коде.
Есть валидаторы, поэтому все ошибки можно описать в том же отдельном классе, что улучшает читабельность и отделяет код от основного.
Для аргументов (паттерн и файл) все еще нет нормального формата, но с помощью валидатора можно их обработку тоже включить в отдельный класс.
Отдельным плюсом является возможность писать свои конверторы (не использовались в данном дз).

В целом считаю, что по описанным выше причинам лучше выбирать JCommander или схожие библиотеки.